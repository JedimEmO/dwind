use dwind_design_tokens::{DesignTokenFile, TokenType, TokenValue};
use std::fs;
use std::io::Write;
use std::path::Path;

/// Color utility class prefixes and their corresponding generator macros
const COLOR_UTILITY_PREFIXES: &[(&str, &str)] = &[
    ("bg", "background-color"),
    ("text", "color"),
];

/// Generate Tailwind-like color utility classes from a design token file
pub fn render_design_token_colors_to_rust_file(
    token_file_path: impl AsRef<Path>,
    output_file_path: impl AsRef<Path>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Parse the design token file
    let token_file_content = fs::read_to_string(token_file_path)?;
    let design_token_file: DesignTokenFile = serde_json::from_str(&token_file_content)?;

    // Extract color tokens
    let color_tokens = extract_color_tokens(&design_token_file);

    // Generate utility classes
    let generated_code = generate_color_utility_classes(&color_tokens);

    // Write to output file
    let mut output_file = fs::File::create(output_file_path)?;
    output_file.write_all(generated_code.as_bytes())?;

    Ok(())
}

/// Extract all color tokens from the design token file
fn extract_color_tokens(design_token_file: &DesignTokenFile) -> Vec<(String, String)> {
    let mut color_tokens = Vec::new();
    let all_tokens = design_token_file.get_all_tokens();

    for (path, token) in all_tokens {
        // Only process color tokens
        if token.token_type != TokenType::Color {
            continue;
        }

        // Extract color value based on token value type
        let color_value = match &token.value {
            TokenValue::Color(color_value) => Some(color_value.hex.clone()),
            TokenValue::Literal(literal) => Some(literal.clone()),
            TokenValue::Expression(_) => {
                // Skip expression tokens for now - they need to be resolved first
                eprintln!(
                    "Warning: Skipping color token '{}' with expression value (not yet supported)",
                    path
                );
                None
            }
        };

        if let Some(value) = color_value {
            color_tokens.push((path, value));
        }
    }

    color_tokens
}

/// Generate Rust code for color utility classes using dwgenerate_map! macro
fn generate_color_utility_classes(color_tokens: &[(String, String)]) -> String {
    let mut output = String::new();

    // Add header comment
    output.push_str("// Auto-generated color utility classes from design tokens\n");
    output.push_str("// Do not edit this file manually\n\n");

    for (prefix, generator_prefix) in COLOR_UTILITY_PREFIXES {
        for (token_path, color_value) in color_tokens {
            let css_rule = format!("{generator_prefix}: {color_value};");
            let utility_name = path_to_class_name(prefix, token_path)
                .to_uppercase()
                .replace("-", "_");
            let utility_prefix = path_to_class_name(prefix, token_path)
                .replace("-", "_");

            output.push_str(&format!(
                "# [doc (hidden)] pub static {utility_name}_RAW: &str = \"{css_rule}\";\n"
            ));
            output.push_str(&format!(
                "#[doc = \"Generated from design token file. class content: {css_rule}\"]\n"
            ));
            output.push_str(&format!("pub static {utility_name}: once_cell::sync::Lazy<String> = once_cell::sync::Lazy::new(|| {{ dominator::class!{{#![prefix=\"{utility_prefix}\"].raw({utility_name}_RAW)}} }});\n"));
        }
    }

    output
}

/// Convert token path to CSS class name for dwgenerate_map!
/// Example: "colors.primary.500" -> "colors-primary-500"
fn path_to_class_name(prefix: &str, token_path: &str) -> String {
    let sanitized_path = sanitize_token_path(token_path);
    if prefix.is_empty() {
        sanitized_path.to_lowercase()
    } else {
        format!(
            "{}-{}",
            prefix.to_lowercase(),
            sanitized_path.to_lowercase()
        )
    }
}

/// Sanitize token path for use in CSS class names
/// Convert dots to dashes and handle special characters
fn sanitize_token_path(path: &str) -> String {
    path.replace('.', "_")
        .replace('-', "_")
        .replace(' ', "_")
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '_')
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use dwind_design_tokens::{ColorValue, DesignToken, TokenType, TokenValue};
    use std::collections::HashMap;

    #[test]
    fn test_sanitize_token_path() {
        assert_eq!(
            sanitize_token_path("colors.primary.500"),
            "colors_primary_500"
        );
        assert_eq!(
            sanitize_token_path("colors.primary-dark.100"),
            "colors_primary_dark_100"
        );
        assert_eq!(
            sanitize_token_path("colors.text color.50"),
            "colors_text_color_50"
        );
    }

    #[test]
    fn test_extract_color_tokens() {
        let mut sets = HashMap::new();
        let mut test_group = HashMap::new();

        // Add a color token
        test_group.insert(
            "primary".to_string(),
            dwind_design_tokens::TokenNode::Token(DesignToken::new(
                TokenValue::Color(ColorValue {
                    color_space: "srgb".to_string(),
                    components: [1.0, 0.0, 0.0],
                    alpha: 1.0,
                    hex: "#ff0000".to_string(),
                }),
                TokenType::Color,
                Some("Primary color".to_string()),
            )),
        );

        sets.insert(
            "colors".to_string(),
            dwind_design_tokens::TokenNode::Group(test_group),
        );

        let design_token_file = DesignTokenFile {
            sets,
            themes: vec![],
            metadata: dwind_design_tokens::Metadata {
                token_set_order: vec!["colors".to_string()],
                active_themes: vec![],
                active_sets: vec!["colors".to_string()],
            },
        };

        let color_tokens = extract_color_tokens(&design_token_file);
        assert_eq!(color_tokens.len(), 1);
        assert_eq!(color_tokens[0].0, "colors.primary");
        assert_eq!(color_tokens[0].1, "#ff0000");
    }

    #[test]
    fn test_generate_color_utility_classes() {
        let color_tokens = vec![
            ("colors.primary.500".to_string(), "#ff0000".to_string()),
            ("colors.secondary.100".to_string(), "#0000ff".to_string()),
        ];

        let result = generate_color_utility_classes(&color_tokens);

        assert!(result.contains("BG_"));
        assert!(result.contains("TEXT_"));
        assert!(result.contains("colors_primary_500"));
        assert!(result.contains("#ff0000"));
        assert!(result.contains("#0000ff"));
    }
}
